// astar.h
// Jose Maria Martinez
// Header of the functions of the astar class
#ifndef __ASTAR_H__
#define __ASTAR_H__

#include "platform_types.h"
#include "Math/float2.h"
#include <vector>

class Map;
class Path;
/** @brief AStarNode struct
*
* Struct that represents a node generated by the A* algorithm
*
*/
struct AStarNode
{
  Float2 position;
  u32 f;
  u32 g;
  u32 h;
  AStarNode* parent;
  /** @brief AStarNode constructor
  *
  * Default AStarNode constructor
  *
  * @return *AStarNode
  */
  AStarNode(Float2 pos, AStarNode* p, s32 step);
  /** @brief AStarNode destructor
  *
  * Default AStarNode destructor
  *
  * @return *AStarNode
  */
  ~AStarNode();
  /** @brief Checks if both nodes have the same state
  *
  * Checks if both nodes have the same state. Which means that both of them
  * have the same position if true.
  *
  * @return bool true if has the same state, false otherwise
  */
  bool hasSameState(const AStarNode& node);
};

enum class AgentDirection
{
  k_East = 0,
  k_West = 1,
  k_South = 2,
  k_North = 3,
  k_Northwest = 4,
  k_Northeast = 5,
  k_Southwest = 6,
  k_Southeast = 7,
  k_PADDING = 255
};

enum class AStarStatus
{
  k_Finished = 0,
  k_Calculating = 1,
  k_PADDING = 255
};
/** @brief AStar class
*
* Class that runs the A* algorithm to search for the best path between an origin and a
* destination
*
*/
class AStar
{
public:
  /** @brief AStar constructor
  *
  * Default AStar constructor
  *
  * @return *AStar
  */
  AStar();
  /** @brief AStar destructor
  *
  * Default AStar destructor
  *
  * @return *AStar
  */
  ~AStar();
  /** @brief Generates the best path path from origin to destination
  *
  * Generates the best path from origin to destination without interruptions and stores it
  * in path. The results this function can give are the following ones.
  * kErrorCode_InvalidPointer-> The path passed is incorrect
  * kErrorCode_InvalidOrigin-> The origin passed is incorrect for the map
  * kErrorCode_InvalidDestination-> The destination is invalid for the map
  * kErrorCode_Memory-> The program was unable to store more memory
  * kErrorCode_PathNotCreated-> The path could not be created, you should not receive this error.
  * kErrorCode_PathNotFound-> There is not a path from origin to dst
  * kErrorCode_Ok-> The path was successfully calculated and is stored at path.
  * 
  * @param origin origin point from we want to start the path
  * @param dst destination point at we want to end the path
  * @param path path that will contain the result
  * @param collisionData collision information of the map
  *
  * @return s16 result of the operation
  */
  s16 generatePath(Float2 origin, Float2 dst, Path* path, const Map& collisionData);
  /** @brief Generates the best path path from origin to destination
  *
  * Generates the best path from origin to destination if it has time and stores it
  * in path. The results this function can give are the following ones.
  * kErrorCode_InvalidPointer-> The path passed is incorrect
  * kErrorCode_InvalidOrigin-> The origin passed is incorrect for the map
  * kErrorCode_InvalidDestination-> The destination is invalid for the map
  * kErrorCode_Memory-> The program was unable to store more memory
  * kErrorCode_PathNotCreated-> The path could not be created, you should not receive this error.
  * kErrorCode_PathNotFound-> There is not a path from origin to dst
  * kErrorCode_Timeout-> The path could not be calculated at this frame, if you call the function
  *   again it will continue from the point it ended.
  * kErrorCode_Ok-> The path was successfully calculated and is stored at path.
  *
  * @param origin origin point from we want to start the path
  * @param dst destination point at we want to end the path
  * @param path path that will contain the result
  * @param collisionData collision information of the map
  * @param timeout time the algorithm has to find the path
  *
  * @return s16 result of the operation
  */
  s16 generatePath(Float2 origin, Float2 dst, Path* path, const Map& collisionData, double timeout);

private:

  std::vector<AStarNode*> open_list_;

  std::vector<AStarNode*> closed_list_;

  u16 base_step_cost_;
  /** @brief checks if an equivalent node is in the closed list
  *
  * Checks if an equivalent node is in the closed list (which means if it has the same position).
  * The position of the node in the closed list will be returned at position if it is, if not there 
  * will be a -1.
  * 
  * @param x x coordinate of the position of the node we want to compare
  * @param y y coordinate of the position of the node we want to compare
  * @param position position of the node in the closed list, -1 if it was not find
  * @return bool true if it was false otherwise
  */
  bool isNodeInClosedList(const float x, const float y, s32* position);
  /** @brief checks if an equivalent node is in the open list
  *
  * Checks if an equivalent node is in the open list (which means if it has the same position).
  * The position of the node in the open list will be returned at position if it is, if not there
  * will be a -1.
  *
  * @param x x coordinate of the position of the node we want to compare
  * @param y y coordinate of the position of the node we want to compare
  * @param position position of the node in the open list, -1 if it was not find
  * @return bool true if it was false otherwise
  */
  bool isNodeInOpenList(const float x, const float y, s32* position);
  /** @brief returns the node with the lowest F at the open list
  *
  * returns the node with the lowest F at the open list
  *
  * @return s32 index of the node with the lowest F
  */
  s32 getLowestFNodeIdx() const;
  /** @brief cleans the open list and closed list
  *
  * cleans the open list and closed list
  *
  * @return void
  */
  void clean();
  /** @brief calculates the heuristic of a node
  *
  * Calculates the heuristic of a node given an origin and a destination
  *
  * @param origin origin that will be used to calculate the heuristic
  * @param dst dst that will be used to calculate the heuristic
  * @return void
  */
  u32 calculateHeuristic(const Float2& origin, const Float2& dst) const;

  AStarStatus actual_state_;

  AStarNode* node_goal = nullptr;

  AStarNode* node_start = nullptr;

  AStarNode* node_current = nullptr;
  /** @brief AStar copy constructor
  *
  * The AStar cannot be copied
  *
  * @return *AStar
  */
  AStar(const AStar& as) = delete;
  /** @brief AStar copy operation
  *
  * The AStar cannot be copied
  *
  * @return *AStar
  */
  AStar operator=(const AStar& as) = delete;

};

#endif